0000000000000000000000000000000000000000 35b214f7f86d9f1da96dfa53ea41661a490e397b vurma <erik.kallman@gmail.com> 1424185611 +0100	branch: Created from HEAD
35b214f7f86d9f1da96dfa53ea41661a490e397b 70eaa686a57dc7e84441b0adfb6f286dc3143622 vurma <erik.kallman@gmail.com> 1424185719 +0100	commit: vurma: to make the sorting function prettier and more effective, i will implement linked-list conversion of the parsed input data. this will facilitate more readable search algorithms and more effective data storage.
70eaa686a57dc7e84441b0adfb6f286dc3143622 b03435ee94bd9349f739875c7eb5191fa2417823 vurma <erik.kallman@gmail.com> 1424190417 +0100	commit: vurma: preliminary skeleton for the linked-list implementation in place. proceeding with writing the get_state_ll function, which will construct the linked list from data in parsed_input.
b03435ee94bd9349f739875c7eb5191fa2417823 1614901961d00b045f4fb5e7e845026d0acdda7d vurma <erik.kallman@gmail.com> 1424266698 +0100	commit: vurma: restructuring the code base into a more modular format.
1614901961d00b045f4fb5e7e845026d0acdda7d c6b612112863e69d8480459fe55b456b9051e453 vurma <erik.kallman@gmail.com> 1424444349 +0100	commit: vurma: there is a bug in the get_numinstr function that i cant identify. if the num_buf array is set to static, i read the eigenvalues correctly from the input file, but not the transition data. If its not defined as static, the opposite situation occurs. Since i cant explain it, i am altering the function to find a way around using that array for extracting the number.
c6b612112863e69d8480459fe55b456b9051e453 ff6d5701877844b74daf5b36f9542b4571eb7c81 vurma <erik.kallman@gmail.com> 1424683850 +0100	commit: vurma: the modified get_numsl function now reads the correct eigenvalues. debugging the transition moment section
ff6d5701877844b74daf5b36f9542b4571eb7c81 189571ed75e1f0aa52e4a1c17238ca5575dbf8c2 vurma <erik.kallman@gmail.com> 1424713395 +0100	commit: vurma:the the init_state_ll allocation now proceeds without error. moving on to debugging the data source error where the wrong transition moments are read.
189571ed75e1f0aa52e4a1c17238ca5575dbf8c2 f1a908c96bde6d70fdf2a6d6bc14a143f8de2279 vurma <erik.kallman@gmail.com> 1424873579 +0100	commit: vurma: the extraction of data and initialization of the data tree now seems to work. im leaving some debug printing in the code in case the next implementation back-fires.
f1a908c96bde6d70fdf2a6d6bc14a143f8de2279 78a22b5bab41d1f88be0ab7471db6a328114039b vurma <erik.kallman@gmail.com> 1424877620 +0100	commit: vurma: cleaned up some variable declarations. now reducing the scope of n_states and n_trans and storing those variables inside the info_node llist.
78a22b5bab41d1f88be0ab7471db6a328114039b 82c13c7d7c0b389259d60e029126a1fe542dc0a1 vurma <erik.kallman@gmail.com> 1424886675 +0100	commit: vurma: n_states and n_trans variables now localized to each info node respectively. the initialization of the state llist was moved outside of the scope of the parse_input function to make the code more readable and the format-specific input parsing functions easier to write. proceeding with implementing a dummy screening function and the Kramers-Heisenberg calculation.
82c13c7d7c0b389259d60e029126a1fe542dc0a1 8ee8ccd649e74698ff3040e303949b284e7cfaba vurma <erik.kallman@gmail.com> 1424886686 +0100	commit: vurma: n_states and n_trans variables now localized to each info node respectively. the initialization of the state llist was moved outside of the scope of the parse_input function to make the code more readable and the format-specific input parsing functions easier to write. proceeding with implementing a dummy screening function and the Kramers-Heisenberg calculation.
8ee8ccd649e74698ff3040e303949b284e7cfaba d3535b0c1a981772163ac73393f49ba0172d9ddf vurma <erik.kallman@gmail.com> 1425287007 +0100	commit: vurma: the k_means algorithm is now functional, but the print statements are still in the code for debugging. moving on to implementing a state selection algorithm that uses the grouped indices from the k_means algorithm along with the fact that there are no inter-group transitions, to obtain a final grouping of states.
d3535b0c1a981772163ac73393f49ba0172d9ddf 1d29e79c1896132001a4e9b4a2430d576bbb99fe vurma <erik.kallman@gmail.com> 1425305758 +0100	commit: vurma: the set_state_ll algorithm now correctly sorts out the ground and intermediate states. moving on to expanding on the j index to also let it set the final state types.
1d29e79c1896132001a4e9b4a2430d576bbb99fe 92acfeb03abe24e18dccbc2b60d692a7797fd9d3 vurma <erik.kallman@gmail.com> 1425312018 +0100	commit: vurma: the sorting algorithm now functions for all state types. test drive this with other input files to validate the algorithm.
92acfeb03abe24e18dccbc2b60d692a7797fd9d3 029503889c04dc249cf57254f74c659dfc7519e8 vurma <erik.kallman@gmail.com> 1425387022 +0100	commit: vurma: the k_means algorithm is now functional and the program runs through valgrind without any invalid writes or reads. proceeding with merging with master and then implementing the screening function.
